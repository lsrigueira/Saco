Estructura del programa
IniciarPrueba.py:  Transcurre el programa principal. Se reduce a un código con un menú que llama a otras funciones.
Funciones.py: No vamos a trabajar con objetos, por lo que agrupé todas las funciones estáticas en este módulo
Controlar.py: Código en python2 cambiado a python3(hago la aclaración por los métodos que se auto-traducen) que se encarga de leer la información de los acelerómetros y generar los .JSON
Constant.py: En él guardamos información importante para el programa que se puede cambiar antes de su ejecución como el número de muestras que obtenemos de cada acelerómetro,  el nombre de los golpes/etiquetas, configuración de cada filtro...
Contenido de los .JSON
<nombreusuario>.json: Se guardan el valor, la etiqueta (Derecha/Izquierda/Frontal) y el momento temporal de todos los golpes dados (y validados) en el "Modo entenamiento"1. Si el usuario no se identifica los golpes se guardarán en "temporal.json"
Historial.json: Se crea en tiempo de ejecución y guarda la potencia, el nombre (crochet,patada...) y la etiqueta de los golpes dados en el "Modo Práctica"1 
<acelerometroX>.json: Contiene todos los valores de las lecturas de los acélerometros con su tiempo correspondiente. Los valores vienen divididos por eje.
Importancia de las sesiones
Un usuario conocido tiene en la base de datos tantos golpes como se hubiesen guardado,al iniciar sesión se cargan los golpes(guardados como un <nombreusuario>.json y se puede empezar a trabajar sobre ellos después de crear un clasificador.
Modos
Modo Entrenamento: Los golpes se guardan en la base de datos del usurio para crear un clasificador posteriormente
Modo Práctica: Los golpes se etiquetan y se calcula su potencia.
Funcionalidades extra
Ver historial: Permite visualizar la hora,el nombre, la etiqueta y la potencia de todos los golpes dados en el "Modo Práctica" en la sesión actual.
Obtener excel: Se crean <nombreusuario>_<nombregolpe>.xlsx en el path indicado en "constant.py" que contiene el vector de cada golpe así como su etiqueta y potencia.
Hardware
El saco de boxeo contiene nueve acelerómetros colocados en tres filas y tres columnas.
Se tardan  entre 300 y 450 ms en realizar una captura completa(depende del estado de la Beagle).
Cada vez que se ejecuta el programa,se realiza un escaneo de todos los puertos para detectar los acelerómetros que hai conectados. 
La lectura de los acelerómetros es cíclica. Los acelérometros están en espera activa hasta que detectan un pico de potencia, entonces el acelerómetro que esté activo en ese momento lee por ordne un valor del eje X,Y,Z cediendo justo después el turno al siguiente acelerómetro. Este proceso se repite el número deseado de veces (por defecto usamos 10)
Calculo de la potencia
Para calcular la potencia, primero calculamos el módulo de un eje, luego calculamos el módulo de cada acelerómetro (esto es, el módulo de sus tres ejes) y finalmente sumamos la potencia de cada acelerómetro.
La media de potencia se calcula,la primera vez, como la media de los diez últimos valores en la base de datos. Después utilizamos los valores del "modo práctica", pero para que la media no se vea afectada por el progresivo cansancio del boxeador, solo contaremos los valores que estén por encima del valor mínimo usado para calcular la media de potencia.
Calibración de los clasificadores.
 Utilizaremos LinearSVC, por ser el SVM con mejores resultados por defecto. El número máximo de iteraciones permitidas para converger vendrá dado por una constante definida en "constants.py".Para intentar combatir el overfitting vamos a utilizar el método "SelectFromModel" al que le pasamos nuestro modelo y reduce la dimensión de los vectores para eliminar lo que considera redundancia. 
La segunda opción (solo disponible teóricamente por el momento) es utilizar un regresor logístico. El regresor logístico tiene mucha más opciones de configuración que el LinearSVC, para elegir las mejores opciones creamos un diccionario de posibilidades y utilizamos el método "GridSearchCV" para que elija los mejores valores por nosotros.
Parámetros del diccionario:  
1)C: Es la regularización del sistema, daremos más resolución a los valores bajos( implica mayor regularización) por ser más precisos.
2)Penalty: Es la penalización aplicada sobre las muestras, probaremos con "L1" y "L2" pero no con "elasticnet" por no ser muestras extremadamente distantes.
3)Multi_class: Utilizaremos "ovr" por ser mejor para pocas etiquetas y óptimo para dos.
4)Class_weight: Dremos mayor peso a las muestras que pertenezcan a la etiqueta con menor número de miembros para intentar equilibrar la balanza("balanced")
5)Solver: Es el algoritmo utilizado para optimizar los resultados. Como estamos usando pocas muestras el mejor el "liblinear". Otra opción válida sería "lbfgs" pero es computacionalmente inviable en nuestro dispositivo
En cambos casos,para comprobar la validez de nuestro clasificador utilizamos dos métodos:
1)Cross_validate: Es un método de la librería "model_selection" de sklearn que nos devuelve la precisión de nuestro clasificador.
2)Empirismo: Escogemos aleatoriamente el 10% de las muestras y las separamos de nuestra base de datos. Creamos un clasificador nuevo y sometemos a este 10% a las predicciones del clasificador comparando el valor obtenido con el valor real conocido. Para mayor fiabilidad repetimos este proceso 100 veces.
Con este método podemos localizar los fallos y saber si son heterogéneos o se deben a alguna muestra mal etiquetada en la base de datos.
Dibujar los vectores
Antes de intentar separar nuestros vectores en etiquetas debemos asegurarnos que estos son separables. Para ello utilizamos una herramienta que permite visualizar vectores de muy grandes dimensiones (TSNE). A esta herramienta le enseñamos nuestros vectores y le indicamos un color por etiqueta haciendo que en la gráfica se puedan distinguir cada grupo.
La gráfica resultante es en dos dimensiones. Es posible que nuestros vectores sean distinguibles y no lo parezcan en la gráfica( ya que estamos intentando pintar cientos de dimensiones en un plano 2D). Lo que no es posible es que aparezcan claramente separados en la gráfica y nuestro clasificador no sea capaz de distinguirlos










